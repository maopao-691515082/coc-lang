import
    util,
    io/bufio,
;
from .. import
    util:  cocc_util,
;

public class TokenList
{
    String              src_fn;
    util.Vector<Token>  tl;
    long                idx;

    TokenList(String fn)
    {
        this.src_fn = fn;
        this.tl     = new util.Vector<Token>(nil);
        this.idx    = 0;
    }

    public String repr()
    {
        return "%r".(this.tl.to_array()[this.idx :]);
    }

    void append(Token t)
    {
        this.tl.add(t);
    }

    void join_str_literal()
    {
        var new_tl = new util.Vector<Token>(nil);

        util.Vector<String> merging_strs;   //合并过程中的临时字符串列表
        var merge = []{
            void do()
            {
                if (merging_strs !== nil)
                {
                    //合并到最后一个token
                    var last_t = new_tl.get(new_tl.size() - 1);
                    cocc_util.assert(last_t.is_literal_str() && last_t.value().eq(merging_strs.get(0)));
                    last_t._value = "".join(merging_strs.iter());
                    merging_strs = nil;
                }
            }
        };
        foreach (var t: this.tl.iter())
        {
            if (merging_strs !== nil)
            {
                //正在合并
                if (t.is_literal_str())
                {
                    //还有字符串字面量，持续合并
                    merging_strs.add(t.value());
                }
                else
                {
                    //结束了，将合并结果写入，并增加t本身
                    merge.do();
                    new_tl.add(t);
                }
            }
            else
            {
                cocc_util.assert(new_tl.size() == 0 || !new_tl.get(new_tl.size() - 1).is_literal_str());
                new_tl.add(t);
                if (t.is_literal_str())
                {
                    //开始合并
                    merging_strs = new util.Vector<String>(nil);
                    merging_strs.add(t.value());
                }
            }
        }
        merge.do(); //收尾

        this.tl = new_tl;
    }

    public bool end()
    {
        return this.idx >= this.tl.size();
    }

    public Token peek()
    {
        if (this.end())
        {
            cocc_util.exit("文件[%s]代码意外结束".(this.src_fn));
        }
        return this.tl.get(this.idx);
    }

    public Token pop()
    {
        var t = this.peek();
        ++ this.idx;
        return t;
    }

    public Token pop_name()
    {
        var t = this.pop();
        if (t.is_name())
        {
            return t;
        }
        t.syntax_err("需要标识符");
    }

    public Token pop_sym(String expect)
    {
        var t = this.pop();
        if (t.is_sym(nil) && (expect === nil || t.value().eq(expect)))
        {
            return t;
        }
        t.syntax_err("需要符号%s".("" if expect === nil else "‘%s’".(expect)));
    }
}

public TokenList parse_token_list(String src_fn)
{
    var src_f = new bufio.File(src_fn, "r");
    defer src_f.close();

    var lines       = src_f.read_lines(),
        token_list  = new TokenList(src_fn),
        in_comment  = false,
        raw_str     = cast<RawStr>(nil),
    ;

    for (long line_idx = 0; line_idx < lines.size(); ++ line_idx)
    {
        var line = lines[line_idx];
        long pos = 0;

        if (in_comment)
        {
            //存在未完的块注释
            pos = line.index("*/");
            if (pos < 0)
            {
                //块注释还没完
                continue;
            }
            //在本行结束，从注释之后继续解析
            pos += 2;
        }
        else if (raw_str !== nil)
        {
            //存在未完的原始字符串
            pos = line.index_char('`');
            if (pos < 0)
            {
                //整行都是，追加
                raw_str.value = "%s%s\n".(raw_str.value, line);
                continue;
            }
            //在本行结束，追加后继续解析
            raw_str.value = raw_str.value.concat(line.sub_str(0, pos));
            token_list.append(new Token{
                type:       TOKEN_TYPE_LITERAL_STR,
                _value:     raw_str.value,
                src_fn:     src_fn,
                line_idx:   raw_str.line_idx,
                pos:        raw_str.pos,
            });
            ++ pos;
        }

        //从pos开始解析当前行
        while (pos < line.len())
        {
            //跳过空格
            for (; pos < line.len(); ++ pos)
            {
                char c = line.char_at(pos);
                if (c != '\t' && c != '\x20')
                {
                    break;
                }
            }
            if (pos >= line.len())
            {
                //行结束
                break;
            }

            if (line.sub_str(pos, line.len()).has_prefix("//"))
            {
                //单行注释，忽略本行
                break;
            }

            if (line.sub_str(pos, line.len()).has_prefix("/*"))
            {
                //块注释开始
                pos += 2;
                var end_pos = line.sub_str(pos, line.len()).index("*/") if pos < line.len() else -1L;
                if (end_pos < 0)
                {
                    //注释跨行，设置标记并跳过本行
                    in_comment = true;
                    break;
                }
                //注释在本行结束，跳过并继续
                pos += end_pos + 2;
                continue;
            }

            if (line.char_at(pos) == '`')
            {
                //原始字符串
                raw_str = new RawStr{
                    value:      nil,
                    line_idx:   line_idx,
                    pos:        pos,
                };
                ++ pos;
                var end_pos = line.sub_str(pos, line.len()).index_char('`') if pos < line.len() else -1L;
                if (end_pos < 0)
                {
                    //原始字符串跨行
                    raw_str.value = line.sub_str(pos, line.len()).concat("\n");
                    break;
                }
                //在本行结束
                raw_str.value = line.sub_str(pos, pos + end_pos);
                token_list.append(new Token{
                    type:       TOKEN_TYPE_LITERAL_STR,
                    _value:     raw_str.value,
                    src_fn:     src_fn,
                    line_idx:   raw_str.line_idx,
                    pos:        raw_str.pos,
                });
                pos += end_pos + 1;
                raw_str = nil;
                continue;
            }

            //解析token
            token_list.append(parse_token(src_fn, line_idx, line, ref pos));
        }
    }

    if (in_comment || raw_str !== nil)
    {
        syntax_err(src_fn, lines.size(), lines[lines.size() - 1].len(), "存在未结束的%s".("块注释" if in_comment else "原始字符串"));
    }

    token_list.join_str_literal();

    return token_list;
}
