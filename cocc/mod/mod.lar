import
    util,
    os/path,
    util/iters,
;
from .. import
    util:   cocc_util,
    token:  cocc_token,
;

public class Mod
{
    String name, dir;

    //导入的模块表，{源码文件: {导入名: 模块全名}}
    util.HashMap<String, util.HashMap<String, String>> dep_mod_map_map;

    //各模块元素的表
    util.HashMap<String, Cls>       cls_map;
    util.HashMap<String, Gcls>      gcls_map;
    util.HashMap<String, GclsInst>  gcls_inst_map;
    util.HashMap<String, Intf>      intf_map;
    util.HashMap<String, Gintf>     gintf_map;
    util.HashMap<String, GintfInst> gintf_inst_map;
    util.HashMap<String, Func>      func_map;
    util.HashMap<String, Gfunc>     gfunc_map;
    util.HashMap<String, GfuncInst> gfunc_inst_map;
    util.HashMap<String, Gv>        gv_map;

    //模块元素的名字集合
    util.HashSet<String> mode_elem_name_set;

    Mod(String mod_name)
    {
        this.name = mod_name;
        this.dir  = find_mod_path(this.name);

        this.dep_mod_map_map = new util.HashMap<String, util.HashMap<String, String>>(nil);

        this.this.cls_map   = new util.HashMap<String, Cls>(nil);
        this.gcls_map       = new util.HashMap<String, Gcls>(nil);
        this.gcls_inst_map  = new util.HashMap<String, GclsInst>(nil);
        this.intf_map       = new util.HashMap<String, Intf>(nil);
        this.gintf_map      = new util.HashMap<String, Gintf>(nil);
        this.gintf_inst_map = new util.HashMap<String, GintfInst>(nil);
        this.func_map       = new util.HashMap<String, Func>(nil);
        this.gfunc_map      = new util.HashMap<String, Gfunc>(nil);
        this.gfunc_inst_map = new util.HashMap<String, GfuncInst>(nil);
        this.gv_map         = new util.HashMap<String, Gv>(nil);

        this.mode_elem_name_set = new util.HashSet<String>(nil);
    }

    void precompile()
    {
        var src_fns = util.sorted(iters.filter(os.list_dir(this.dir).iter(), []{
            public bool is_valid(String fn)
            {
                return fn.has_suffix(".coc");
            }
        }));
        foreach (var fn: fns.iter())
        {
            var full_fn = "%s/%s".(this.dir, fn);
            if (!os.lstat(full_fn).is_file())
            {
                exit("[%s]需要是一个文件".(full_fn));
            }

            var token_list = cocc_token.parse_token_list(full_fn);

            var dep_mod_map = new util.HashMap<String, String>(nil);
            dep_mod_map_map.set(fn, dep_mod_map);

            var import_end = false;
            while (!token_list.end())
            {
                var t = token_list.peek();
                if (t.is_reserved("import"))
                {
                    //解析import
                    if (import_end)
                    {
                        t.syntax_err("import必须在模块代码最前面");
                    }
                    this.parse_import(token_list, dep_mod_map);
                    continue;
                }
                import_end = true;  //标识import段解析完毕
                cocc_util.exit("todo");
            }
        }

        cocc_util.exit("todo");
    }

    void parse_import(cocc_token.TokenList token_list, util.HashMap<String, String> dep_mod_map)
    {
        var t = token_list.pop();
        cocc_util.assert(t.is_reserved("import"));

        var mnl = new util.Vector<String>(nil);
        for (;;)
        {
            t = token_list.pop_name();
            mnl.add(t.value());
            if (!token_list.peek().is_sym("/"))
            {
                break;
            }
            token_list.pop_sym("/");
        }
        assert(mnl.size() > 0);

        if (token_list.peek().is_sym(":"))
        {
            //有别名
            token_list.pop_sym(":");
            t = token_list.pop_name();
        }

        var mn = t.value(),
            full_mn = "/".join(mnl.iter());
        if (dep_mod_map.contains_key(mn))
        {
            t.syntax_err("导入模块重名");
        }
        dep_mod_map.set(mn, full_mn);

        token_list.pop_sym(";");
    }
}
